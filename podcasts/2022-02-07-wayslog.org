* 个人介绍
** 个人资料
   - wayslog，网络id也是 wayslog
   - github: github.com/wayslog
   - rustcc社区运营者,与诸多大佬谈笑风生，rust最菜讲师之一，rust的干饭人。
** 工作/学习经历
   双非大学混毕业的，历任七牛、饿了么、B站，ByteDance
* Rust 初印象
** 为什么入坑，用时多久才算有点心得
*** 结缘
    大概是2015年5月份，也就是rust刚刚发布1.0版本的时候。那时候正好在毕业季，我早早的就把毕业论文写完了，闲着没事儿想学点儿新东西。

    (说起来毕业论文，我那年的毕业论文还是给k8s做一套管理系统来着。应该算是国内比较早的k8s适配了吧。)
    正好在论坛上看到有人在讨论这门语言，于是就开始去学了，然后一发不可收拾，一直用到现在。
    
    我算是国内最早一批跟着rust逐步发展壮大的人，从最开始的白板写代码，到racer，rls，现在的ra，IDE,算是见证了这门语言在国内的兴起吧。

*** 入坑之路
    至于用了多久，额，好像我花了一个礼拜（全力）去学完了之后就有很多想去做的东西了。
    
    但是当时rust能写的东西确实是有点少，各种库都不完全，很多时候写到差不多了才发现少了个至关重要的库，要么熟悉的我自己造一个三角形的轮子顶上，要么不熟悉的干脆只能干瞪眼。

*** 社区运营之路
    # 《Rust Primer》
    我觉得吧，rust这点星星之火能在国内发展起来，与我们rustcc社区的同学们的积极努力是分不开的。

    大概就在15年年末吧，社区里的 mike.tang 召集大家来一起参与起来，一起出一本中文版的rust教程资料。

    然后我也领了一章来写，但是后来社区里有好几个人鸽掉了。我和老唐商量一下，一人再写4章。终于在自己立的flag的时间到之前写完了这本书。算是中文社区里的第一本rust教程吧，所以我们给它取名《Rust Primer》，

    一是表明本书是为了rust的初学者准备的，二也是想让rust社区像个初学者一样，逐渐壮大和繁荣。
    
    当然了，从现在的视角来看，当时的行为还是太理想主义了，这本教程从质量上就不是一本合格的教程。
    
    不同作者之间的描述能力差距很大，有很多作者能好好的写代码，但是让他归纳总结写出来，就很难，写的很一般。
    
    甚至我们在审阅的过程中还发现了不少作者直接对着官方的 《TRPL》 做的机翻改动。但是让我和老唐再都改一遍显然也不现实。
    
    另外要维护这本书也很困难，我尝试维护了三年多吧，但也只是在原书的基础上修修补补打补丁。但是官方的2018版本的发布, 彻底断绝了我们维护下去的可能，于是最后也就停止更新了。
    
** Rust与其他编程语言的区别
   最开始看上rust的其实是cargo，而且当时我也在找一门简单的C++替代品。
   
   后来喜欢上rust的其实是因为我觉得它很符合逻辑。只要掌握几个基本的定理，其他的东西都是可以推断出来的。
   
   然后就是rust没有GC，这在我写某个数据处理计算软件的时候被Go的GC极大的干扰了计算流程，然后换Rust一下就解决了。
   
* 深入浅出rust
  
** 学习rust有哪些常见的坑
   我觉得还是所有权和lifetime系统。 我在和其他人介绍rust的时候，经常提的一句话就是：
   
   能clone就clone，能rc就rc，没事儿别写lifetime，编译器推断不出来的，你换个人看你代码的时候照样推断不出来。
   
   rust写的不多不少的时候总会去思考，这个地方是不是达到了 zero cost，能不能通过design和lifetime的组合来规避掉这种开销。

   但是其实这是完全没必要的，大胆的clone就完事儿了。等做完了之后通过profiling再优化也来得及。
   
** Rust未来发展方向
   我本人是做中间件出身的，我觉得rust在中间件领域天生的适合。包括之前的嘉宾阿星也在做这方面的事情，可以说我们的想法一致。
   
   当然了，不同方向上的rust从业者的努力也不容忽视。
   
   比如我现在所在的字节跳动里，他们用rust做飞书你敢信？
   
   还有WebAssembly和区块链的发展也是很迅猛，虽然我关注的不多。
   
   另外还有kernel里的rust支持，我觉得也是一个很好的方向。之前看到有人拿rust做bpf的前端，这就是一个很好的思路。
   
   当然了，现在的rust从业者数量还没达到顶点，不过我觉得也是应当的，渗透和发展也是在慢慢壮大的。

   
* 描述一两件有趣的事情
** 既然是有关于rust，那我得说说我维护的cache-proxy的事儿了
   我和上期嘉宾黄师傅一样，是做cache出身。在阿B那里也在做cache相关的事情，我们先做了一版Golang版本的。
   
   我们很轻松的写出了原先C版本(twemproxy）1/4的性能，但是再往上提升就很难提升了，我们做了很多的优化，效果都不甚理想。同时，由于阿B业务方的用法不规范，导致Golang的内存经常处于被撑爆的状态。
   
   在我们的运维抠门不给机器之后，我决定痛定思痛，用上班之余的时间写了一个rust的版本。然后，这个版本以原Go版本 2/3 的 CPU 开销， 5%的内存开销，以及 upper_99 小 10ms 的效率直接击败了原来的版本。
 
   现在应该仍然在B站内部发挥着它的作用，我估计B站90%的cache-proxy都是它。

   当然了，这个玩意儿在写的时候，还没有async/await的完整实现，于是我只能裸写了很多future状态机。现在想想，还真勇。
   
** 再讲讲我们rustcc水群的流浪之旅吧
   最开始rustcc只有一个大群，没错，在最原始的时候只有一个QQ群来做我们的社区主要活动地盘。
   
   然后后来学rust的人逐渐变多，群也逐渐的从一个分裂成了四个2000人大群，甚至我们还专门划分出来了一个水群，就是OT群。
   大家看我平时摸鱼摸的又多又大，就把群主给我了。
   
   后来吧，因为聊了些违禁的话题，我们被 TX gank 了，群被封了，于是大家只能作出一个违背祖宗的决定，举家迁移至了telegram。
   
   这也就是 rust.cc社区深（摸）水（鱼）群 的由来。
   
   当然，在一次次的搬迁之中我们流失了很多人，但是我们同样也留下了很多人，而且一个一个的都是大水怪。
   
   有这么一个社区，还是蛮好的。
   
* 推荐环节
** 推荐贴
   毛笔：《多宝塔》——颜真卿。
   
   硬笔：《九成宫醴泉铭》——欧阳询。
   
   与很多人的推荐不同，我推荐的这是两本字帖。在我们日益焦躁和不安的时候，写字能达到心灵的澄澈。
   
   当然了，硬笔的话不要求用什么高级钢笔，0.7的晨光中性笔就好。纸可以买贵一点的，我现在在用的练习纸大概60张一沓，十沓大概十几块钱。不过放心，十几块钱的纸绝对够你写的。
   
   至于毛笔就比较贵了，置办一套兼毫笔+墨汁+半熟宣纸+书法毛毡 大概得一百块钱左右了。

   写写字，字里行间体会书法的美丽，哪怕体会不到，写写字放松放松也挺好的。

* 焦点问答
  
** 关于wangyin的rust讨论
*** 关于赋值语法
    我已经不记得我多久没写过 rust 变量的具体类型了，大部分情况下省略即可。
*** variable bind shadow
    我想这一点可以从工程实践上来解决。首先不同类型不同指向的变量名字必然不同，另外不应该出现足够长的block使得你有重复bind的机会。
*** 类型推导
    我也不知道 ra 的作者是不是听信了 wangyin 的鬼话，现在 ra 插件里已经能自动推算类型并且默认显示了。
    
    对我来说其实无所谓，我自己写代码的时候大部分时间都是白板写码，我在写的时候其实也不需要过分的对齐类型。甚至最后整合一下就是了。
*** 动作的返回值 与 return 语句
    这两个我想一起说。
    rust 的 block 其实是有返回值的，函数当然有返回值，但是任意一个代码块也是有的。最后一行的代码作为代码块的返回值是rust的一种默认规则。
    
    而return可以视为这种block规则中的特例，特指了函数的返回值。
    
    至于多分支返回值造成的问题，我觉得在工程代码里不是问题。我们在工程代码里不会写这种代码。大部分情况下我们写的是：
   #+BEGIN_SRC org
    fn add_one(x: i32) -> i32 {
      if x < 5 {
        // 做很多事
        return x + 1;
      }
      if x < 10 {
        // 做很多事
        return x*2;
      }
      // 做很多事
      x /2
    }
   #+END_SRC

   我们会将分支情况提前return，并将hotpath或者主要路径写在最后，写成原文那样的人，大概code review 都过不了。
*** 数组可变性
    这一点我觉得没必要做区分，首先rust中数组其实用的很少，大多数人用的其实是 slice 。

    而可变性这里实际上始终指的是对 slice 本身的可变性，slice内部的每个元素的可变性都是继承自 slice 自己来的。

    这个就是我们说的，可变性的继承。

    不理解的话，你可以考虑一下，为什么 fn do_something(&mut self) 可以修改 self 的字段？

*** 关于lifetime和内存管理
    别用lifetime,答应我，OK？

    这里有一个很有意思的Rust写链表的问题。我相信很多人都觉得rust写不来链表。但是我觉得吧，就像没有人用C++智能指针写链表一样，用rust写链表就不能用 raw pointer 了嘛？

    当然是OK的，只要你能订好stable和unstable的界限，那么这个世界就是合理切安全的。

* Reference

 - aster: https://github.com/wayslog/aster
 - rustcc 深水群： https://t.me/rust_deep_water
 - lark VC rust team 招人： https://job.toutiao.com/s/LbDKJPc

